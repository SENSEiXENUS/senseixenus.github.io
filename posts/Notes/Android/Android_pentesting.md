---------------

### ANDROID PENTESTING

--------------

### Exporting apk with adb

--------------

- Use `adb shell pm list packages` to list packages
- Use `adb shell pm path <path>` to get path
- Lastly `adb pull <path> <destination>` to copy it.

--------------

### Using Drozer

--------------

![image](https://github.com/user-attachments/assets/832161c8-7ad2-40a2-9688-df1c615637e6)

--------------

- Install the drozer-agent apk from [Source](https://github.com/WithSecureLabs/drozer-agent/releases)

![image](https://github.com/user-attachments/assets/4f3b3da4-54d6-4b00-8fb5-fa167a962a98)

- Connect to the agent with drozer on port `31415`

`drozer console connect --server <ip-addr>`

- But, since it is an emulator `nox-player`,you should portforward with `adb` or `Android Debug Bridge`.

Syntax-: `adb forward tcp:<port> tcp:<port>`

![image](https://github.com/user-attachments/assets/f20c29bd-be43-446e-b5b8-84914f09d8e6)

- Connect

![image](https://github.com/user-attachments/assets/d5606bcb-a55e-4bd0-b5de-3d6afee5b651)

------------

### Drozer Console Commands

------------

- Retrieving package information, use shell module  `app.package.list`

Syntax-:`run app.package.list -f <package>`

![image](https://github.com/user-attachments/assets/a5ee8da5-8068-4ee7-8607-a159aba4160b)

- Gathering package infor `app.package.info`

Syntax-:`run app.package.info -a <package's identifier>`

![image](https://github.com/user-attachments/assets/d362da5b-a9a0-47b9-aa85-0adc1bfcaed7)

- Identify the attack surface with `app.package.attacksurface`, if an app is debuggable,we can add adb and step through the code.

Syntax-:`run app.package.attacksurface <identifier>`

![image](https://github.com/user-attachments/assets/307a44e3-246c-48c2-92ea-e61a3370b136)

- Spotting activities allowed in the app with `app.activity.info`

Syntax-:`run app.activity.info -a <identifier>`

![image](https://github.com/user-attachments/assets/831022ef-7607-436e-a1df-dc70addc2da7)

- Use `help [module]` to check on more info on a module.

![image](https://github.com/user-attachments/assets/4658ac7d-1018-453f-addc-6669a5814211)

- In the image detailing the actions of `app.package.info`, an exported activity `com.mwr.example.sieve.PWList` can be carried without authorization or permission.We will use `app.package.start` to start it and exploit the activity.

Syntax-:` run app.activity.start --component [identifier] [activity]`

![image](https://github.com/user-attachments/assets/f54cc3e6-eb5d-4dbb-9e84-fa07b9306f22)

![image](https://github.com/user-attachments/assets/aaa1e730-39ca-4393-b473-e6e0a00b9213)

- Reading from Content-provider,module `app.provider.info` can be used to gather the content information exported from the app.

Syntax-:`run app.provider.info -a [identifier]`

![image](https://github.com/user-attachments/assets/b5da396e-8f2b-4930-a46b-46b722d66b36)

- Use module `scanner.provider.finduris` to scan for multiple urls and define a list of possible urls

Syntax-:`run scanner.provider.finduris -a [identifier]`

![image](https://github.com/user-attachments/assets/7fe72cca-a14c-4fb7-8a3f-7391961289de)

- Then, use module `app.provider.query` to grab the secrets

Syntax-:`run app.provider.query content://[url]`

![image](https://github.com/user-attachments/assets/a26e2495-7bb2-4074-9ccb-ce2200fa76f4)

- Inserting a string into a sqlite database

```
run app.provider.insert <content uris> --string pin 1111 --string Password H4ck3d
run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/
```

![image](https://github.com/user-attachments/assets/b4ce5082-6a67-461a-b71d-63f0821e23ee)

- Use module `scanner.provider.sqltables` to view the sql tables of a server.

Syntax-:```run scanner.provider.sqltables -a <identifier>```

![image](https://github.com/user-attachments/assets/30cf83d1-604c-44ad-a3f3-1e1b203a6754)

- Sql injection with module `app.provider.query`

Syntax-:`run app.provider.query <content uri> --projection "* FROM SQLITE_MASTER where type=’table’;--"`

![image](https://github.com/user-attachments/assets/2a6e7fff-05e4-45d0-a82a-a64d8deeda17)

- Trying a true statement

`run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --selection "1 or 1=1"`

![image](https://github.com/user-attachments/assets/2a866298-b587-467c-b6ed-5996c50e69ab)

- In the sieve app, for example, we have a file backup provider that backs up various files from the storage. Now, if an attacker was to use this provider’s interface to view internal system files, it would be a critical vulnerability. In the following command, the same has been demonstrated.

Syntax-:`run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts`

![image](https://github.com/user-attachments/assets/c2d807dd-1f7b-4a9b-ad9b-0963b11a6ea0)

--------------------

### REFERENCE-:

--------------------

- [HackingArticles](https://www.hackingarticles.in/android-penetration-testing-drozer/)

-------------------

### Decompiling apk files

------------------

- Apktool-:

`apktool d -rs <apk>`

------------------

### Converting dex files to jar files

------------------

- D2j-dex2jar-:

`d2j-dex2jar <classes.dex>`

------------------

### Use jadx-gui to read decompiled jar file

------------------

- Jadx-gui-:

`jadx-gui <classes.jar>`

------------------

### Android Internals 101

-------------------

### What happens when an Android phone boots up

------------------

- We'll look at the `Zygote` and its role in firing up an application.
- This is how it goes
  - Boot ROM
  - Bootloader
  - Kernel
  - Init
  - Dalvik VM
  - Zygote
  - System Servers
  - Managers

----------------

### BOOT ROM

---------------

- The BootROM contains the initial code that run as soon as a device wakes up.It is a mask ROM or a write-protected chip.It is stored in a chip and it loads the bootloader into the RAM for execution.
- Examples-:
  - iPhone boot ROM. Embedded in the mask ROM and can’t be modified. Loads the next stage boot loader from flash or USB (in DFU mode) and verifies its signature using built-in RSA implementation. Also provides accelerated decryption functions for the next stage bootloader.
  - TI’s OMAP4 boot ROM. Can load user code from flash (NOR, NAND, OneNAND), external memory, SD/MMC, USB or UART. Boot order and options are set by strap (SYSBOOT) pins. Provides some functionality for later stages (cache/TLB management etc.)
  - NXP’s LPCxxxx series Boot ROM. Placed in a hidden portion of the internal flash which is mapped at 0 on power-on. Implements CRP (code read protection), ISP (In-System Programming) which allows to upload and flash new code over UART. If a valid user code is in flash (needs to have proper checksum), maps it to 0 and jumps to it. A part of bootrom remains mapped to provide IAP (In-Application Programming) and some other services.

-----------------

### Bootloader

-----------------

- The bootloader is a piece of code that runs before any operating system.It is responsible for loading an operating system.It sets up a minimal environment in which OS can run and begin the the start up process.Bootloader is not specific to Android.In the context of Android (pun intended!) you might’ve heard of OEM manufacturers placing certain limitations on the operating system (eg: limited background processes). This is where those rules are stored.
- One of the major tasks of the the bootloader is stetting up memory management and security options which is vital for the Kernel.Bootloader contains two important files: init.s and main.c.
- Init.s is responsible for initializing stacks, and BSS segments. It eventually calls main.c which is responsible for initializing hardware such as keyboard, system clock, console etc.
- Lastly,it verifies the state of the boot and the integrity partitions before moving execution to the Kernel.

-----------------

### Kernel

-----------------

- Once the Kernel starts,it starts setup cache, loads drivers, mounts file system and starts kernel daemons.After the system setup,it looks for init.s process in system files and launch the root first process.It facilitates communication between the software and the hardware.

--------------

### Init

---------------

- This is a very crucial process. It is where the directories such as /dev, /sys, /proc are mounted. This is also the place where init.rc script is executed.
- Init process also starts the daemons such as bluetooth daemon, adb daemon etc. These handle low level hardware interface including radio interface.If you take a look at init.rc script you’ll find that it includes commands such as “start vold” for file system, “trigger zygote” for starting the Zygote process in Android.One of the most important things that happens during this init process is a call to start the Zygote. The app_process command starts the ART or Dalvik VM and also give a call to Zygote’s main() method.


--------------

### Zygote and VM

----------------

- When the command `app_process()` launches the Zygote, first a VM instance is created and then a call to Zygote's `main()` is made.
- According to dictionary definition: Zygote is the first cell that’s formed during fertilisation. Similarly, Zygote is the first Android specific process when Android OS boots up!”.Zygote preloads all the system resources and classes used by the Android framework thus achieving fast app launches.Zygote preloads all the system resources and classes used by the Android framework thus achieving app launch.The Zygote forks itself to start a “system-server”. The system-server starts services such as ActivityManagerService, Hardware services etc.
- It starts a listening socket interface in the background to ensure creation of new vms for Application processes. On receiving a new request, it forks itself to create a new process which gets a pre-initialized VM instance.
- This forking is available due to copy-on-write resource management technique. It doesn’t copy anything actually, just points to the pages of the parent process. The actual copying happens when there is a new write to the process’ pages.
- The forking happens very efficiently. A new Dalvik VM is created, process gets its own thread and resources to work with. This enables code sharing among VMs thus resulting in minimal startup time.

---------------

### SYSTEM SERVERS

---------------

- This is the first process started by the Zygote.It loads a native library called `Android_servers` that provides interfaces to native functionalities.
- It starts initializing each system service and and registering them with the previously started Service Manager. Each service runs in a separate Dalvik thread in system server.
- ActivityManager is responsible for starting the Launcher App and registering click listeners to it. It also manages the activity lifecycle, maintains activity stack etc.
- System Server also starts other services beginning with com.android such as com.android.phone, com.android.email. It also starts other managers such as Location Manager, Bluetooth Manager etc.

----------------

### Activity Manager

----------------

- It is responsible for activity thread process creation, activity stack management and activity lifecycle management. At the end, it launches an intent to start Home Launcher and registers on click listeners to it. Whenever a click is detected, it launches new apps from icons on home screen.
- The click events are transferred to AcitivityManagerService via Binder IPC. AMS performs multiple steps:
- Collect info about the target intent of intent object. It does so using resolveIntent() method.
- Information about target is saved back into the intent object.
- Now, it’s checked if the user can actually access the target using grantUriPermissionLocked() method.
- Then AMS checks if the intent needs to be opened as a new task. It check for flags such as FLAG_ACTIVITY_NEW_TASK etc.
- If the process doesn’t already exist for the target, the AMS has to create a new process for this.

------------------

### Android Architecture Build Process

-----------------




-----------------

### SSL Unpinning with Objection [another approach]

-----------------

- Android sdk installer:- [windows](https://dl.google.com/android/installer_r24.4.1-windows.exe),[Linux](http://dl.google.com/android/repository/tools_r24.4.1-linux.zip),[Macos](http://dl.google.com/android/repository/tools_r24.4.1-macosx.zip). Check [Stack Overflow](https://stackoverflow.com/questions/37505709/how-do-i-download-the-android-sdk-without-downloading-android-studio)
- Check this [repo](https://github.com/codepath/android_guides/wiki/installing-android-sdk-tools) to install android-sdk.

- Patch with objection first

Syntax-:`objection patchapk -s <apk's name>`

![image](https://github.com/user-attachments/assets/19695516-d85a-4f73-993e-adfbc71193ee)

- On linux, if you noticed an error `mostly in red`,download apktool from the source and install.It is due to the `dirty` version.

- Newly signed apk

![image](https://github.com/user-attachments/assets/edd7d44a-1ff8-4894-8278-8ff7bfeeb78a)

- Install with `adb install <apk>`

----------------

### APK DEBUG PROCESS

--------------

### Understanding the Java Virtual Machine

--------------

- JVM is a virtual machine that allows the computer to run application compiled by java bytecode.It basically helps to convert java byte code to machine code and allows compiled code to be run by a virtual machine and not on hardware.JVM was designed for with huge storage and power which was why the Dalvik Vm was created.Bytecode is a set of instructions desined for efficient execution by an interpreter.Whereas Java bytecode is the instruction set of the Java Virtual Machine.

--------------

### Android Virtual Machine

-------------

- Every Android has it virtual machine, from Android 1.0 to 4.4,it was "Dalvik",Google experimentally introduced `ART` or `Android Runtime`.Android users had the opportunity to choose between `Dalvik` and `ART` in Android 4.4.The `.class` generated contains the JVM class bytecodes.Android has its own optimized bytecode fromat called the `Dalvik` from version 1.0 to 4.4.Dalvik bytecodes are instructions set for a processor.

-------------

### Compilation process

-------------

- The compilation process converts the `.class` and `.jar` libraries into a single `.dex` file containing dalvik byte codes.This is possible with the dx command.`DEX` means `Dalvik Executable`.

-------------

### ART over DALVIK

-------------

- Android migrated to `ART` in `Android 4.4`.This execution environment executes dex properly.The benefit of ART over Dalvik is that the app runs and launches faster on ART, this is because DEX bytecode has been translated into machine code during installation, no extra time is needed to compile it during the runtime.The JIT based compilation in the previously used Dalvik has disadvantages of poor battery life, application lag, and performance.ART is based on the `Ahead-of-Time` compilaton process where compilation begins before a process starts.In ART, the compilation process happens during the app installation process itself. Even though this leads to higher app installation time, it reduces app lag, increases battery usage efficiency, etc.In Android version 7.0, JIT came back. The hybrid environment combining features from both a JIT compiler and ART was introduced.

--------------

### Understanding the whole process

--------------

- The  `src` folders stores the java and kotlin source code
- Resource files are stored in the res folder.
- The `Android Interface Definition Language [AIDL]` allows you to define the programming interface for client and service communication using `IPC`.`IPC` is inter process communication.AIDL can be used between any process in Android.
- `Library modules` contains java or kotlin classes, Android Components and resoures, although assets are not supported.The codes and resources of the library project are compiled and packaged with the application.Therefore, an library module can be a compile time artifact.
- `Android library` compiles into an `Android Archive (AAR)` file that you can use as a dependency for an Android app module.AAR files can contain Android resources and a manifest file, which allows you to bundle in shared resources like layouts and drawables in addition to Java or Kotlin classes and methods.
- `JAR Libraries` is a Java library and unlike AAR it cannot contain Android resources and manifests.
- `Android Asset Packaging Tool (aapt2)` compiles the AndroidManifest and resource files into a single apk.It is divided into two steps `compiling` and `linking`.It improves performance since it is only one file changes.You only need to compile one file and link with the intermediate files.It also support android file resources like drawables and xml.When you invoke AAPT2 for compilation, you should pass a single resource file as an input per invocation.AAPT2 then parses the file and generates an intermediate binary file with a .flat extension.The link phase merges all the intermediate files generated in the compile phase and outputs one .apk file. You can also generate R.java and proguard-rules at this time.
- `Resources.arsc`: The output .apk file does not include the DEX file, so the DEX file is not included, and since it is not signed, it is an APK that cannot be executed.It contains the metadata information of the resourses such as the index of all resources in the packages.An apk is a binary file,and the APK that can be actually executed, and the APK that you often build and execute are uncompressed and can be used simply by expanding it in memory.The R.java that is output with the APK is assigned a unique ID, which allows the Java code to use the resource during compilation as seen below.`Arsc`  is the index of the resource used when executing the application.

![image](https://github.com/user-attachments/assets/2e4ae108-40dd-4109-9e7c-6d2fefcc64ed)

- Starting from Android studio 3.1,D8 waas made the official compiler.D8 produces smaller dex files with better performance when compared with the old dx.R8 is used to compile the code. R8 is an optimized version of D8.D8 plays the role of dexer that converts class files into DEX files and the role of desugar that converts Java 8 functions into bytecode that can be executed by Android.R8 further optimizes the dex bytecode. R8 provides features like optimization, obfuscation, remove unused classes.Obfuscation reduces the size of your app by shortening the names of classes, methods, and fields.Optimization reduces the DEX file size by rewriting unnecessary parts and inlining.By doing Desugaring we can use the convenient language features of Java 8 in older devices.
- `Dex and Multidex` -:`R8` compiles one file known as the `classes.dex`.If you are using Multidex, that is not the case, but multiple DEX files will appear, but for the time being, classes.dex will be created.If the number of application method exceeeds `65536` including the reference libraries, a build error will occur.The method ID range is 0 to 0xFFFF[0 to 65535].In order to avoid this, it is useful to review the dependency of the application and use R8 to remove unused code or use Multidex.e.g

![image](https://github.com/user-attachments/assets/36531de4-c22c-4e0d-a37f-acffa211746d)

----------------

### Signing the apk

----------------

- All apks require a digital signature before they can be installed or updated on your device.For Debug builds, Android Studio automatically signs the app using the debug certificate generated by the Android SDK tools when we run.A debug Keystore and a debug certificate is automatically created.For release builds, you need a Keystore and upload the key to build a signed app. You can either make an APK file with apkbuilder and finally optimize with zipalign on cmd or have Android Studio handle it for you with the ‘Generated Signed Apk option’.

![image](https://github.com/user-attachments/assets/b8692c66-279c-441b-8dee-b0f353facdfe)

-------------------

### Java for Android

-------------------

- [Setting up Nox player with Android Studio](https://www.bing.com/videos/riverview/relatedvideo?q=Using+nox+player+with+android+studio&cvid=b29688070320425aaa0d477f20f84d80&gs_lcrp=EgRlZGdlKgYIABBFGDkyBggAEEUYOTIGCAEQABhAMgYIAhAAGEAyBggDEAAYQDIGCAQQABhAMgYIBRAAGEAyBggGEAAYQDIGCAcQABhAMgYICBAAGEDSAQg2OTYwajBqOagCCLACAQ&PC=U531&ru=%2fsearch%3fq%3dUsing%2bnox%2bplayer%2bwith%2bandroid%2bstudio%26cvid%3db29688070320425aaa0d477f20f84d80%26gs_lcrp%3dEgRlZGdlKgYIABBFGDkyBggAEEUYOTIGCAEQABhAMgYIAhAAGEAyBggDEAAYQDIGCAQQABhAMgYIBRAAGEAyBggGEAAYQDIGCAcQABhAMgYICBAAGEDSAQg2OTYwajBqOagCCLACAQ%26FORM%3dANAB01%26PC%3dU531&mmscn=vwrc&mid=89CE5ADEA3A06D77F6F689CE5ADEA3A06D77F6F6&FORM=WRVORC&ntb=1&msockid=ef18adc9e78e11ef97614a278e8d2535)
- `Hello world` code in java-:

```java
public class Hello {
	public static void main(String[] args){
    System.out.println("Hello world!!");		
	}
}
```

- Commenting in java, use `//`

```java
//TODO-:
```

- Running java code on cmd, use `java file.java`

![image](https://github.com/user-attachments/assets/ce672ff9-29ae-4ba1-93c5-5b3f17b0ae55)

- Variable and arithmetic operators

```java
public class Hello {
	public static void main(String[] args){
    System.out.println("Hello world!!");
    //Number
    int number = -5;
    System.out.println(number);	
	}
}
```

- The `long` keyword can also be used to store integers and can store up  `2 ^ 63`.

```java
long number = 5;
System.out.println(num);
```

- For decimal numbers, use `float` or `double`

```java
public class Hello {
	public static void main(String[] args){
    System.out.println("Hello world!!");
    //Number
    int number = -5;
    System.out.println(number);
    long num = 5;
    System.out.println(num);
    double myDouble = 2.5;
    //float
    float myFloat = (float) 2.9;
    System.out.println(myDouble);	
    System.out.println(myFloat);
	}
}
```

- You can also use `char` to store characters and unicode values

```java
char myChar = "M";
char myUnicodeChar =  "\u00A9";
System.out.println(myChar);
System.out.println(myUnicodeChar);
```












