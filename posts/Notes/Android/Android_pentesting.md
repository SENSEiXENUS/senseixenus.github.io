---------------

### ANDROID PENTESTING

--------------

### Exporting apk with adb

--------------

- Use `adb shell pm list packages` to list packages
- Use `adb shell pm path <path>` to get path
- Lastly `adb pull <path> <destination>` to copy it.

--------------

### Using Drozer

--------------

![image](https://github.com/user-attachments/assets/832161c8-7ad2-40a2-9688-df1c615637e6)

--------------

- Install the drozer-agent apk from [Source](https://github.com/WithSecureLabs/drozer-agent/releases)

![image](https://github.com/user-attachments/assets/4f3b3da4-54d6-4b00-8fb5-fa167a962a98)

- Connect to the agent with drozer on port `31415`

`drozer console connect --server <ip-addr>`

- But, since it is an emulator `nox-player`,you should portforward with `adb` or `Android Debug Bridge`.

Syntax-: `adb forward tcp:<port> tcp:<port>`

![image](https://github.com/user-attachments/assets/f20c29bd-be43-446e-b5b8-84914f09d8e6)

- Connect

![image](https://github.com/user-attachments/assets/d5606bcb-a55e-4bd0-b5de-3d6afee5b651)

------------

### Drozer Console Commands

------------

- Retrieving package information, use shell module  `app.package.list`

Syntax-:`run app.package.list -f <package>`

![image](https://github.com/user-attachments/assets/a5ee8da5-8068-4ee7-8607-a159aba4160b)

- Gathering package infor `app.package.info`

Syntax-:`run app.package.info -a <package's identifier>`

![image](https://github.com/user-attachments/assets/d362da5b-a9a0-47b9-aa85-0adc1bfcaed7)

- Identify the attack surface with `app.package.attacksurface`, if an app is debuggable,we can add adb and step through the code.

Syntax-:`run app.package.attacksurface <identifier>`

![image](https://github.com/user-attachments/assets/307a44e3-246c-48c2-92ea-e61a3370b136)

- Spotting activities allowed in the app with `app.activity.info`

Syntax-:`run app.activity.info -a <identifier>`

![image](https://github.com/user-attachments/assets/831022ef-7607-436e-a1df-dc70addc2da7)

- Use `help [module]` to check on more info on a module.

![image](https://github.com/user-attachments/assets/4658ac7d-1018-453f-addc-6669a5814211)

- In the image detailing the actions of `app.package.info`, an exported activity `com.mwr.example.sieve.PWList` can be carried without authorization or permission.We will use `app.package.start` to start it and exploit the activity.

Syntax-:` run app.activity.start --component [identifier] [activity]`

![image](https://github.com/user-attachments/assets/f54cc3e6-eb5d-4dbb-9e84-fa07b9306f22)

![image](https://github.com/user-attachments/assets/aaa1e730-39ca-4393-b473-e6e0a00b9213)

- Reading from Content-provider,module `app.provider.info` can be used to gather the content information exported from the app.

Syntax-:`run app.provider.info -a [identifier]`

![image](https://github.com/user-attachments/assets/b5da396e-8f2b-4930-a46b-46b722d66b36)

- Use module `scanner.provider.finduris` to scan for multiple urls and define a list of possible urls

Syntax-:`run scanner.provider.finduris -a [identifier]`

![image](https://github.com/user-attachments/assets/7fe72cca-a14c-4fb7-8a3f-7391961289de)

- Then, use module `app.provider.query` to grab the secrets

Syntax-:`run app.provider.query content://[url]`

![image](https://github.com/user-attachments/assets/a26e2495-7bb2-4074-9ccb-ce2200fa76f4)

- Inserting a string into a sqlite database

```
run app.provider.insert <content uris> --string pin 1111 --string Password H4ck3d
run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/
```

![image](https://github.com/user-attachments/assets/b4ce5082-6a67-461a-b71d-63f0821e23ee)

- Use module `scanner.provider.sqltables` to view the sql tables of a server.

Syntax-:```run scanner.provider.sqltables -a <identifier>```

![image](https://github.com/user-attachments/assets/30cf83d1-604c-44ad-a3f3-1e1b203a6754)

- Sql injection with module `app.provider.query`

Syntax-:`run app.provider.query <content uri> --projection "* FROM SQLITE_MASTER where type=’table’;--"`

![image](https://github.com/user-attachments/assets/2a6e7fff-05e4-45d0-a82a-a64d8deeda17)

- Trying a true statement

`run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --selection "1 or 1=1"`

![image](https://github.com/user-attachments/assets/2a866298-b587-467c-b6ed-5996c50e69ab)

- In the sieve app, for example, we have a file backup provider that backs up various files from the storage. Now, if an attacker was to use this provider’s interface to view internal system files, it would be a critical vulnerability. In the following command, the same has been demonstrated.

Syntax-:`run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts`

![image](https://github.com/user-attachments/assets/c2d807dd-1f7b-4a9b-ad9b-0963b11a6ea0)

--------------------

### REFERENCE-:

--------------------

- [HackingArticles](https://www.hackingarticles.in/android-penetration-testing-drozer/)

-------------------

### Decompiling apk files

------------------

- Apktool-:

`apktool d -rs <apk>`

------------------

### Converting dex files to jar files

------------------

- D2j-dex2jar-:

`d2j-dex2jar <classes.dex>`

------------------

### Use jadx-gui to read decompiled jar file

------------------

- Jadx-gui-:

`jadx-gui <classes.jar>`

------------------

### Android Internals 101

-------------------

### What happens when an Android phone boots up

------------------

- We'll look at the `Zygote` and its role in firing up an application.
- This is how it goes
  - Boot ROM
  - Bootloader
  - Kernel
  - Init
  - Dalvik VM
  - Zygote
  - System Servers
  - Managers

----------------

### BOOT ROM

---------------

- The BootROM contains the initial code that run as soon as a device wakes up.It is a mask ROM or a write-protected chip.It is stored in a chip and it loads the bootloader into the RAM for execution.
- Examples-:
  - iPhone boot ROM. Embedded in the mask ROM and can’t be modified. Loads the next stage boot loader from flash or USB (in DFU mode) and verifies its signature using built-in RSA implementation. Also provides accelerated decryption functions for the next stage bootloader.
  - TI’s OMAP4 boot ROM. Can load user code from flash (NOR, NAND, OneNAND), external memory, SD/MMC, USB or UART. Boot order and options are set by strap (SYSBOOT) pins. Provides some functionality for later stages (cache/TLB management etc.)
  - NXP’s LPCxxxx series Boot ROM. Placed in a hidden portion of the internal flash which is mapped at 0 on power-on. Implements CRP (code read protection), ISP (In-System Programming) which allows to upload and flash new code over UART. If a valid user code is in flash (needs to have proper checksum), maps it to 0 and jumps to it. A part of bootrom remains mapped to provide IAP (In-Application Programming) and some other services.

-----------------

### Bootloader

-----------------

- The bootloader is a piece of code that runs before any operating system.It is responsible for loading an operating system.It sets up a minimal environment in which OS can run and begin the the start up process.Bootloader is not specific to Android.In the context of Android (pun intended!) you might’ve heard of OEM manufacturers placing certain limitations on the operating system (eg: limited background processes). This is where those rules are stored.
- One of the major tasks of the the bootloader is stetting up memory management and security options which is vital for the Kernel.Bootloader contains two important files: init.s and main.c.
- Init.s is responsible for initializing stacks, and BSS segments. It eventually calls main.c which is responsible for initializing hardware such as keyboard, system clock, console etc.
- Lastly,it verifies the state of the boot and the integrity partitions before moving execution to the Kernel.

-----------------

### Kernel

-----------------

- Once the Kernel starts,it starts setup cache, loads drivers, mounts file system and starts kernel daemons.After the system setup,it looks for init.s process in system files and launch the root first process.It facilitates communication between the software and the hardware.

--------------

### Init

---------------

- This is a very crucial process. It is where the directories such as /dev, /sys, /proc are mounted. This is also the place where init.rc script is executed.
- Init process also starts the daemons such as bluetooth daemon, adb daemon etc. These handle low level hardware interface including radio interface.If you take a look at init.rc script you’ll find that it includes commands such as “start vold” for file system, “trigger zygote” for starting the Zygote process in Android.One of the most important things that happens during this init process is a call to start the Zygote. The app_process command starts the ART or Dalvik VM and also give a call to Zygote’s main() method.


--------------

### Zygote and VM

----------------

- When the command `app_process()` launches the Zygote, first a VM instance is created and then a call to Zygote's `main()` is made.
- According to dictionary definition: Zygote is the first cell that’s formed during fertilisation. Similarly, Zygote is the first Android specific process when Android OS boots up!”.Zygote preloads all the system resources and classes used by the Android framework thus achieving fast app launches.Zygote preloads all the system resources and classes used by the Android framework thus achieving app launch.The Zygote forks itself to start a “system-server”. The system-server starts services such as ActivityManagerService, Hardware services etc.
- It starts a listening socket interface in the background to ensure creation of new vms for Application processes. On receiving a new request, it forks itself to create a new process which gets a pre-initialized VM instance.
- This forking is available due to copy-on-write resource management technique. It doesn’t copy anything actually, just points to the pages of the parent process. The actual copying happens when there is a new write to the process’ pages.
- The forking happens very efficiently. A new Dalvik VM is created, process gets its own thread and resources to work with. This enables code sharing among VMs thus resulting in minimal startup time.

---------------

### SYSTEM SERVERS

---------------

- This is the first process started by the Zygote.It loads a native library called `Android_servers` that provides interfaces to native functionalities.
- It starts initializing each system service and and registering them with the previously started Service Manager. Each service runs in a separate Dalvik thread in system server.
- ActivityManager is responsible for starting the Launcher App and registering click listeners to it. It also manages the activity lifecycle, maintains activity stack etc.
- System Server also starts other services beginning with com.android such as com.android.phone, com.android.email. It also starts other managers such as Location Manager, Bluetooth Manager etc.

----------------

### Activity Manager

----------------

- It is responsible for activity thread process creation, activity stack management and activity lifecycle management. At the end, it launches an intent to start Home Launcher and registers on click listeners to it. Whenever a click is detected, it launches new apps from icons on home screen.
- The click events are transferred to AcitivityManagerService via Binder IPC. AMS performs multiple steps:
- Collect info about the target intent of intent object. It does so using resolveIntent() method.
- Information about target is saved back into the intent object.
- Now, it’s checked if the user can actually access the target using grantUriPermissionLocked() method.
- Then AMS checks if the intent needs to be opened as a new task. It check for flags such as FLAG_ACTIVITY_NEW_TASK etc.
- If the process doesn’t already exist for the target, the AMS has to create a new process for this.

------------------

### Android Architecture Build Process

-----------------




-----------------

### SSL Unpinning with Objection [another approach]

-----------------

- Android sdk installer:- [windows](https://dl.google.com/android/installer_r24.4.1-windows.exe),[Linux](http://dl.google.com/android/repository/tools_r24.4.1-linux.zip),[Macos](http://dl.google.com/android/repository/tools_r24.4.1-macosx.zip). Check [Stack Overflow](https://stackoverflow.com/questions/37505709/how-do-i-download-the-android-sdk-without-downloading-android-studio)
- Check this [repo](https://github.com/codepath/android_guides/wiki/installing-android-sdk-tools) to install android-sdk.

- Patch with objection first

Syntax-:`objection patchapk -s <apk's name>`

![image](https://github.com/user-attachments/assets/19695516-d85a-4f73-993e-adfbc71193ee)

- On linux, if you noticed an error `mostly in red`,download apktool from the source and install.It is due to the `dirty` version.

- Newly signed apk

![image](https://github.com/user-attachments/assets/edd7d44a-1ff8-4894-8278-8ff7bfeeb78a)

- Install with `adb install <apk>`

----------------

### APK DEBUG PROCESS

--------------

### Understanding the Java Virtual Machine

--------------

- JVM is a virtual machine that allows the computer to run application compiled by java bytecode.It basically helps to convert java byte code to machine code and allows compiled code to be run by a virtual machine and not on hardware.JVM was designed for with huge storage and power which was why the Dalvik Vm was created.Bytecode is a set of instructions desined for efficient execution by an interpreter.Whereas Java bytecode is the instruction set of the Java Virtual Machine.

--------------

### Android Virtual Machine

-------------

- Every Android has it virtual machine, from Android 1.0 to 4.4,it was "Dalvik",Google experimentally introduced `ART` or `Android Runtime`.Android users had the opportunity to choose between `Dalvik` and `ART` in Android 4.4.The `.class` generated contains the JVM class bytecodes.Android has its own optimized bytecode fromat called the `Dalvik` from version 1.0 to 4.4.Dalvik bytecodes are instructions set for a processor.

-------------

### Compilation process

-------------

- The compilation process converts the `.class` and `.jar` libraries into a single `.dex` file containing dalvik byte codes.This is possible with the dx command.`DEX` means `Dalvik Executable`.

-------------

### ART over DALVIK

-------------

- Android migrated to `ART` in `Android 4.4`.This execution environment executes dex properly.The benefit of ART over Dalvik is that the app runs and launches faster on ART, this is because DEX bytecode has been translated into machine code during installation, no extra time is needed to compile it during the runtime.The JIT based compilation in the previously used Dalvik has disadvantages of poor battery life, application lag, and performance.ART is based on the `Ahead-of-Time` compilaton process where compilation begins before a process starts.In ART, the compilation process happens during the app installation process itself. Even though this leads to higher app installation time, it reduces app lag, increases battery usage efficiency, etc.In Android version 7.0, JIT came back. The hybrid environment combining features from both a JIT compiler and ART was introduced.

--------------

### Understanding the whole process

--------------

- The  `src` folders stores the java and kotlin source code
- Resource files are stored in the res folder.
- The `Android Interface Definition Language [AIDL]` allows you to define the programming interface for client and service communication using `IPC`.`IPC` is inter process communication.AIDL can be used between any process in Android.
- `Library modules` contains java or kotlin classes, Android Components and resoures, although assets are not supported.The codes and resources of the library project are compiled and packaged with the application.Therefore, an library module can be a compile time artifact.
- `Android library` compiles into an `Android Archive (AAR)` file that you can use as a dependency for an Android app module.AAR files can contain Android resources and a manifest file, which allows you to bundle in shared resources like layouts and drawables in addition to Java or Kotlin classes and methods.
- `JAR Libraries` is a Java library and unlike AAR it cannot contain Android resources and manifests.
- `Android Asset Packaging Tool (aapt2)` compiles the AndroidManifest and resource files into a single apk.It is divided into two steps `compiling` and `linking`.It improves performance since it is only one file changes.You only need to compile one file and link with the intermediate files.It also support android file resources like drawables and xml.When you invoke AAPT2 for compilation, you should pass a single resource file as an input per invocation.AAPT2 then parses the file and generates an intermediate binary file with a .flat extension.The link phase merges all the intermediate files generated in the compile phase and outputs one .apk file. You can also generate R.java and proguard-rules at this time.
- `Resources.arsc`: The output .apk file does not include the DEX file, so the DEX file is not included, and since it is not signed, it is an APK that cannot be executed.It contains the metadata information of the resourses such as the index of all resources in the packages.An apk is a binary file,and the APK that can be actually executed, and the APK that you often build and execute are uncompressed and can be used simply by expanding it in memory.The R.java that is output with the APK is assigned a unique ID, which allows the Java code to use the resource during compilation as seen below.`Arsc`  is the index of the resource used when executing the application.

![image](https://github.com/user-attachments/assets/2e4ae108-40dd-4109-9e7c-6d2fefcc64ed)

- Starting from Android studio 3.1,D8 waas made the official compiler.D8 produces smaller dex files with better performance when compared with the old dx.R8 is used to compile the code. R8 is an optimized version of D8.D8 plays the role of dexer that converts class files into DEX files and the role of desugar that converts Java 8 functions into bytecode that can be executed by Android.R8 further optimizes the dex bytecode. R8 provides features like optimization, obfuscation, remove unused classes.Obfuscation reduces the size of your app by shortening the names of classes, methods, and fields.Optimization reduces the DEX file size by rewriting unnecessary parts and inlining.By doing Desugaring we can use the convenient language features of Java 8 in older devices.
- `Dex and Multidex` -:`R8` compiles one file known as the `classes.dex`.If you are using Multidex, that is not the case, but multiple DEX files will appear, but for the time being, classes.dex will be created.If the number of application method exceeeds `65536` including the reference libraries, a build error will occur.The method ID range is 0 to 0xFFFF[0 to 65535].In order to avoid this, it is useful to review the dependency of the application and use R8 to remove unused code or use Multidex.e.g

![image](https://github.com/user-attachments/assets/36531de4-c22c-4e0d-a37f-acffa211746d)

----------------

### Signing the apk

----------------

- All apks require a digital signature before they can be installed or updated on your device.For Debug builds, Android Studio automatically signs the app using the debug certificate generated by the Android SDK tools when we run.A debug Keystore and a debug certificate is automatically created.For release builds, you need a Keystore and upload the key to build a signed app. You can either make an APK file with apkbuilder and finally optimize with zipalign on cmd or have Android Studio handle it for you with the ‘Generated Signed Apk option’.

![image](https://github.com/user-attachments/assets/b8692c66-279c-441b-8dee-b0f353facdfe)

-------------------

### Java for Android

-------------------

- [Setting up Nox player with Android Studio](https://www.bing.com/videos/riverview/relatedvideo?q=Using+nox+player+with+android+studio&cvid=b29688070320425aaa0d477f20f84d80&gs_lcrp=EgRlZGdlKgYIABBFGDkyBggAEEUYOTIGCAEQABhAMgYIAhAAGEAyBggDEAAYQDIGCAQQABhAMgYIBRAAGEAyBggGEAAYQDIGCAcQABhAMgYICBAAGEDSAQg2OTYwajBqOagCCLACAQ&PC=U531&ru=%2fsearch%3fq%3dUsing%2bnox%2bplayer%2bwith%2bandroid%2bstudio%26cvid%3db29688070320425aaa0d477f20f84d80%26gs_lcrp%3dEgRlZGdlKgYIABBFGDkyBggAEEUYOTIGCAEQABhAMgYIAhAAGEAyBggDEAAYQDIGCAQQABhAMgYIBRAAGEAyBggGEAAYQDIGCAcQABhAMgYICBAAGEDSAQg2OTYwajBqOagCCLACAQ%26FORM%3dANAB01%26PC%3dU531&mmscn=vwrc&mid=89CE5ADEA3A06D77F6F689CE5ADEA3A06D77F6F6&FORM=WRVORC&ntb=1&msockid=ef18adc9e78e11ef97614a278e8d2535)
- `Hello world` code in java-:

```java
public class Hello {
	public static void main(String[] args){
    System.out.println("Hello world!!");		
	}
}
```

- Commenting in java, use `//`

```java
//TODO-:
```

- Running java code on cmd, use `java file.java`

![image](https://github.com/user-attachments/assets/ce672ff9-29ae-4ba1-93c5-5b3f17b0ae55)

- Variable and arithmetic operators

```java
public class Hello {
	public static void main(String[] args){
    System.out.println("Hello world!!");
    //Number
    int number = -5;
    System.out.println(number);	
	}
}
```

- The `long` keyword can also be used to store integers and can store up  `2 ^ 63`.

```java
long number = 5;
System.out.println(num);
```

- For decimal numbers, use `float` or `double`

```java
public class Hello {
	public static void main(String[] args){
    System.out.println("Hello world!!");
    //Number
    int number = -5;
    System.out.println(number);
    long num = 5;
    System.out.println(num);
    double myDouble = 2.5;
    //float
    float myFloat = (float) 2.9;
    System.out.println(myDouble);	
    System.out.println(myFloat);
	}
}
```

- You can also use `char` to  store unicode values

```java
char myUnicodeChar =  '\u00A9';
System.out.println(myChar);
System.out.println(myUnicodeChar);
```

- Use `String` for characters

```java
String myString = "Meisma";
```

- For boolean, use `Boolean` for `true` or `false`

```java
Boolean myBool = true;
```

- Instead of using `int` or `long` to hold huge numbers, `double` can also be used.

```java
int a  =  5;
int b  = 10;
double answer =  (double) a / b ;
System.out.println(answer);
```

- Adding `String` in java

```java
String string1 = "Man";
String string2 = "go";
System.out.println(string1 + string2);
```

-------------

### Relational  and Logical Operators && Conditions

----------------

- Conditions

```java

int num = 9;
if (num>10) {
   System.out.println("Greater than 10");
} else {
   Systemm.out.println("Lesser thn 10");
}

```

- Switch and Case statement

```java
switch (num) {
   case 10:
        System.out.println("Wrong");
        break;
   case 9:
        System.out.println("Correct");
        break;
   default:
        System.out.println("LMAO!!!");
        break;				
}
```

--------------

### Loops

--------------

- while loop-:

```java
public class Main {
	public static void main(String[] args) {
		int num = 0;
		while (true) {
			num+=1;
			System.out.println("Hello");
		    if (num == 7) {
			   System.out.println("Life is hard");
		       break;
			}
		}
	}
}
```

- You can also use special keywords like `break` and `continue` in a `while` loop
- You can also use `do` statement

```java
do{
  System.out.println("Milk");
} while (x<5);
```

- The `scanner` is used to input a number.You have to import the class `Scanner` from `java.util.Scanner`.

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        System.out.println("Enter a number: ");
        Scanner myScanner = Scanner(System.in);
        int answer = new myScanner.nextInt(); //nextInt() should be used for a number
        System.out.println("The answer is :" + answer);
    }
}
```

- For a string Scanner, use

```java
String string = new myScanner.next();
```
----------------

- Java Options pane-: A useful package for receiving user input is the `JOptionsPane` class.Import with 

```java
import javax.swing.JOptionsPane;
```
- Generating a random number with class `Random`.

```java
import java.util.Random;

public class Main {
	public static void main(String[] args){
		System.out.println("Random numbers");
		Random random = new Random();
		int number = random.nextInt();
		System.out.println(number);
	}
}
```

- Setting limit for random number

```java
int number = random.nextInt(20); //The argument 20 is the limit
```

- `Simple Arrays`-:
- Initializing new array with values

```java
public class Main {
	public static void main(String[] args) {
		//Arrays in java
	     String[] students = {"Meisam","Zombies","Daddy","Great","Deadbeat"};
		 System.out.println(students[0]);  
	}
}
```

- Creating an array with a defined memory

```java
public class Main {
	public static void main(String[] args) {
		 //Arrays in java
	         String[] students = new String[5]; //Defining the amount of memory
		 students[0] = "Meisam";
		 students[1] = "Sarah";
		 System.out.println(students[0]);  
		 
	}
}
```

- Accessing all the elements of an array with `for` loop

```java
public class Main {
	public static void main(String[] args) {
		//Arrays in java
	     String[] students = new String[5];
		 students[0] = "Meisam";
		 students[1] = "Sarah";
		 students[2] = "Sarah";
		 students[3] = "Sarah";
		 students[4] = "Sarah";
		 for (int i=0; i<5; i++) {
			 System.out.println(students[i]);
		 }
		 
	}
}
```

- You can also get the length of an array with the `length` class

```java
public class Main {
	public static void main(String[] args) {
		//Arrays in java
	     String[] students = new String[5];
		 students[0] = "Meisam";
		 students[1] = "Sarah";
		 students[2] = "Sarah";
		 students[3] = "Sarah";
		 students[4] = "Sarah";
		 System.out.println("[+] Array's length is : " + students.length);
		 for (int i=0; i<students.length; i++) {
			 System.out.println(students[i]);
		 }
		 
	}
}
```

----------------

### Object Oriented Programming

----------------

- Defining a class which should be saved in a file e.g `Phone.java`

```java
public class Phone {
	String name;
	int phoneNumber;
	int userSignature;
	String userModel;
	String imeiString;
}
```

- Instantiating a class in `main` class

```java
public class Main {
	public static void main(String[] args) {
		Phone iphone = new Phone();//Creating an instance of a class
		//Attributes
		iphone.name = "Iphone 11"; 
		iphone.phoneNumber = "08109978500";
		//Accessing the field of a class
		System.out.println(iphone.name);
	}
}
```

- Creating a function in java `public void Name(String me)`

```java
public class Phone {
	String name;
	String phoneNumber;
	//Creating a methodd
	//If you don't want to return any value, use the keyword void as seen below
	public void printString(String trackName) {
		System.out.println("Playing track :" + trackName);
	}
}
```

- Calling a method

```java
iphone.printString("Bahubali");
```

- `Access modifiers` helps to restrict the scope of a class, constructor, variable, method, or data member. It provides security, accessibility, etc. to the user depending upon the access modifier used with the element.It can be `public`, `private`, `default` and `protected`.If you don't use anything as the modifier,it is `public`.

```java
public class Phone {
	String name;
	String phoneNumber;
	//Use of access modifiers
	public String model = "SM-1234";
```

- Calling it

```java
System.out.println(iphone.model);
```

- Although this `private` fields can be accessed by a method in the class

```java
public class Phone {
	String name;
	String phoneNumber;
	//Use of access modifiers
	private String model = "SM-1234";
	//Creating a methodd
	//If you don't want to return any value, use the keyword void as seen below
	public void printString(String trackName) {
		System.out.println("Playing track :" + trackName);
	}
	public void accessPrivateField() {
		System.out.println(model);
	} 
}
```

- Setting a value with a method and also get a value with a method even if it is set to private-:

```java
public class Phone {
	private String name;
	String phoneNumber;
	//Use of access modifiers
	private String model = "SM-1234";
	//Creating a methodd
	//If you don't want to return any value, use the keyword void as seen below
	public void printString(String trackName) {
		System.out.println("Playing track :" + trackName);
	}
	public void accessPrivateField() {
		System.out.println(model);
	}
    //set class field 'name'	
	public void setName(String name){
		this.name = name;
	}
	//return class field name	
	public String getName() {
		return this.name;
	}
}
```

- Calling it-:

```java
public class Main {
	public static void main(String[] args) {
		Phone iphone = new Phone();//Creating an instance of a class
		//Attributes
		//iphone.name = "Iphone 11"; 
		iphone.phoneNumber = "08109484844978500";
		//Accessing the field of a class
		//System.out.println(iphone.name);
		iphone.accessPrivateField();
		iphone.printString("Bahubali");
		iphone.setName("Iphone 22");
		//System.out.println(iphone.name);
		System.out.println(iphone.getName());
	}
}
```

---------------

### Creating a constructor

--------------

- A constructor in Java is a special method used to initialize objects. It is called when an instance of a class is created, and it can set initial values for object attributes. Constructors are essential for creating and initializing objects in Java.

```java
public Phone(String name,String phoneNumber) {
		this.name = this.name;
		this.phoneNumber = phoneNumber;
		this.model =  "SM-1234";
	}
```

- Creating classes and subclasses

SuperClass Animal-:

```java
public class Animal {
	private String name;
	private String typeA;
	private int legNumbers;
	private Boolean hasTail;
	
	public Animal(String name,String typeA,int legNumber,Boolean hasTail) {
		this.name = name;
		this.typeA = typeA;
		this.legNumbers = legNumber;
		this.hasTail = hasTail;
	}
	
	public void setName(String name) {
	    this.name = name;
	
	}
	public void setTypeA(String name) {
	    this.typeA = typeA;
	
	}
}
```
- Subclasss `Bird`-:Fields are passed to the super class `Animal` with `super()` object

```java
public class Bird extends Animal {
	public Bird(String name,String typeA,int legNumber,Boolean hasTail){
	super(name,typeA,legNumber,hasTail);
	}
}
```

- Instatiating the class `Bird`

```java
//Bird
public class Main{
	public static void main(String[] args) {
		//Instatiating our Bird class
		Bird phoenix = new Bird("Bangis","Parrot",10,true);
		//Setting a Name
		phoenix.setName("Hawk");
		//Accessing the superclass function
		System.out.println(phoenix.getName());
	}
}
```
- You can also create other fields within a subclass that won't be passed to the super class but you have to extend the class and not the constructor.

```java
public class Bird extends Animal {
	private int wings;
	public Bird (String name,String typeA,int legNumber,Boolean hasTail,int wings){
	super(name,typeA,legNumber,hasTail);
	this.wings = wings;
	}
	public void canFly() {
		if (this.wings > 0) {
			System.out.println("[+]Can fly");
		} else {
			System.out.println("[+]Cannot fly");
		}
	}
	public void setWings(int wings) {
		this.wings = wings;
	}
	public int getWings() {
		return this.wings;
	}
}
```

- You can also override method in the main class with the `@Override` keyword.

Animal class-:

```java
public void eat(String food) {
		System.out.println(this.name + " eats " + food);
	}
```

Bird Class-:

```java
@Override
	public void eat(String food) {
		super.eat(food);
	}
```

- Polymorphism refers to a class having multiple constructors or two methods doing two different stuffs.The core feature of polymorphism is the data type parameter.

```java
public void canFly() {
		if (this.wings > 0) {
			System.out.println("[+]Can fly");
		} else {
			System.out.println("[+]Cannot fly");
		}
	}
	public void canFly(int wings){
		if (wings > 0) {
			System.out.println("[+]Can fly");
		} else {
			System.out.println("[+]Cannot fly");
		}
	}
```

- `Null` keyword
- `final` keyword is used to create a constant.

```java
final String x = "Sleep";
x = "sleep";
System.out.println(x);
```

![image](https://github.com/user-attachments/assets/36d55de0-864d-4aa1-bcc3-004705d411e2)

--------------

### ArrayList

--------------

- Import with -:

```java
import java.util.ArrayList
```

- Initializing a new `Arraylist`

```java
ArrayList<String> names = new ArrayList<>();
```

- Adding a value with the add() method

```java
names.add("Meisam");
names.add("Sarah");
```

- Picking a value with function `get()`

```java
names.get(0);
```

- Length of the `ArrayList`

```java
names.size();
```
- Use `contains` to check if an `Arraylist` contains a value,It will return a `boolean`.

```java
names.contains("Shayla");
```

- Remove a value with `remove()`

```java
names.remove("Value");
```

- To print the index of a value

```java
names.indexOf("Shayla");
```

- Check if it is empty with `isEmpty` function

```java
names.isEmpty()
```
-------------------

### MAP

-------------------

- Import `Map`

```java
import java.util.Map;
```

- Initialzing a `map` but to instantiate object `HashMap`, use `import java.util.HashMap`

```java
//<> contains the  data type for the key and value
Map<String,String> contacts = new HashMap<String, String>();
```

- To add a value, use `put()`

```java
contacts.put("Meisam","08109978500");
```

- To retrieve a value, use `get()`

```java
contacts.get("Meisam");
```

- Getting the size of a Map

```java
contacts.size()
```

- Remove a key

```java
contacts.remove("Meisam");
```

- Check is a value exists with `containsKey()` and `containsValue()`

```java
contacts.containsKey("Me");
contacts.containsValue("08109978585858558");
```
- Syntax for each loop-:

```text
for (type var : array) {
    statements using var;
}
```

-------------------

### Static keyword - Inner Classes

-----------------

- When the `static` keyword is a dded to a field, it does work for instance of the object but the object itself.It should not be added to the constructor the class.e.g

```java
public class Student {
	public static String name;
	private int id;
	private String falseName;
	public Student(int id,String falseName) {
		this.id = id;
	}
	public void setName(String name){
		this.name =  name;
	}
	public void setId(int id){
		this.id =  id;
	}
	public void setFalseName(String falseName) {
		this.falseName = falseName;
	}
	public String getName(){
		return this.name;
	}
	public int getId(){
		return this.id;
	}
	public String getFalseName(){
		return this.falseName;
	}
}
```

- You can only set the static variable with a setter and accessed with getters as seen above.

```java
public class Main {
	public static void main(String[] args) {
		Student student = new Student(10,"Sarah");
	    student.setName("Lame");
		System.out.println(student.getName());
		 
	}
}
```

- Although variables with the `static` keyword can be changed by calling the Class directly.The `static` method is memory friendly and can be ensure memory handling.

```java
Student.name =  "Kris";
```

- Inner Classes are classes within a class.

```java
public class Student {
	private int id;
	private String name;
	
	public class innerClass {
		private int innerId;
		private String innerName;
		
		public innerClass(int innerId,String innerName) {
			this.innerId = innerId;
			this.innerName = innerName;
		}
	}
}
```

- Instatiating an inner class

```java
Student.innerClass inner = new Student().new innerClass(1,"Name");
```

- 
